#!/usr/bin/env python3

import numpy
import argparse
import time
import os
import sys

import util

class Program:
	_args = None

	def __init__(self):
		parser = argparse.ArgumentParser(
			description="Guest model.")
		parser.add_argument('-d', '--stats-dir', type=str,
			default='/host', required=True,
			help='directory of statistics provided by the host')
		self._args = parser.parse_args()
		#print(self._args)

	def main(self):
		try:
			if not os.path.isdir(self._args.stats_dir): raise Exception('parameter --stats-dir="{}" not found a directory'.format(self._args.stats_dir))

			host_stats = util.WatchLog('{}/stats-1'.format(self._args.stats_dir), 'json')

			model1m   = Model('model-1m',  600)
			#model5m   = Model('model-5m',  300)
			#model10m  = Model('model-10m', 600)

			while True:
				time.sleep(1)

				lines = host_stats.read()
				for l in lines:
					model1m.feed(l)
					#model5m.feed(l)
					#model10m.feed(l)

				model1m.predict()
				#model5m.predict()
				#model10m.predict()

		# Exit conditions:
		except KeyboardInterrupt:
			return 0
		'''except Exception as e:
			sys.stderr.write('error: {}\n'.format(str(e)))
			return 1  #'''
		return 0

class Model:
	# Statistics origin
	_prefix        = None
	_file_name     = None
	_sample_limit  = 0
	# Hardware information
	_cpus          = None
	_cpu_list      = None
	# Time Serie Values:
	_sample_size   = 0
	_total_percent = []   # cpu time (normalized by cpus)
	_total_demand  = None # cpu time + steal time of all VMs (Markov Chain) (normalized by total_vcpus)
	_total_vcpus   = []   # number of VCPUs of all VMs
	_vcpus         = None
	_vcpu_percent  = []
	_vcpu_steal    = []

	def __init__(self, prefix, sample_limit):
		assert sample_limit >= 0
		self._prefix       = prefix
		self._sample_limit = sample_limit
		self._total_demand = MarkovChain(11, sample_limit=sample_limit) # 0-10 states

	def feed(self, line):
		self._sample_size += 1
		if self._cpus == None:
			self._cpu_list = []
			cpumap = line['vm_totals']['map']
			self._cpus = cpumap.count(True)
			for i in range(0, len(cpumap)):
				if cpumap[i] == True: self._cpu_list.append(i)
		if self._vcpus == None:
			self._vcpus = line['vm']['vcpu_count']

		total_percent_aux = sum([ line['cpu'][i]['guest'] for i in self._cpu_list ]) / 100.
		total_vcpus_aux = line['vm_totals']['vcpu_count']
		total_demand_aux = total_percent_aux + (line['vm_totals']['steal']/100.)
		#print('cpus={}, cpulist={}, total_percent_aux={}, total_vcpus_aux={}, total_demand_aux={}'.format(self._cpus, self._cpu_list, total_percent_aux, total_vcpus_aux, total_demand_aux))

		self._total_percent.append( total_percent_aux / self._cpus ) # normalized by the number of CPUs
		self._total_vcpus.append(total_vcpus_aux)

		self._vcpu_percent.append( sum([ line['vm']['vcpu'][i]['usage'] for i in range(0,self._vcpus) ]) /100. )
		self._vcpu_steal.append( sum([ line['vm']['vcpu'][i]['steal'] for i in range(0,self._vcpus) ]) /100. )

		if total_demand_aux == 0: total_demand_aux = 0.1
		total_demand_pervcpu = int(round(10* self._cpus / total_demand_aux, 0))
		#print('total_demand_pervcpu={}'.format(total_demand_pervcpu))
		if total_demand_pervcpu > 10: total_demand_pervcpu = 10
		self._total_demand.increment(total_demand_pervcpu)

		if self._sample_limit > 0:
			while self._sample_size > self._sample_limit:
				self._sample_size -=1
				self._total_percent.pop(0)
				self._total_vcpus.pop(0)
				self._vcpu_percent.pop(0)
				self._vcpu_steal.pop(0)

	def predict(self):
		print( '{}: Histogram    : {}'.format(self._prefix, self._total_demand.histogram().tolist()) )
		print( '{}: Markov Chain : {}'.format(self._prefix, self._total_demand.predictNext().tolist()) )

class MarkovChain:
	_size   = None # Matrix size
	_names  = None # State names
	_counts = None # Line sum
	_matrix = None # Transition matrix
	_sample_limit = 0
	_sample_size  = 0
	_sample       = []
	_last_state = None

	def __init__(self, size, names=None, sample_limit=0):
		assert isinstance(size, int) and size > 1
		assert names == None or (isinstance(names, list) and len(names) == size)
		assert isinstance(sample_limit, int) and sample_limit >= 0
		self._size = size
		self._names = names
		self._sample_limit = sample_limit
		self._counts = [ 0 for i in range(0,size) ]
		self._matrix = numpy.array( [ [ 0 for j in range(0,size) ] for i in range(0,size) ] )

	def getMatrix(self):
		ret = numpy.array( [ [ 0. for j in range(0,self._size) ] for i in range(0,self._size) ] )
		for i in range(0,self._size):
			ret[i] = self._matrix[i]/self._counts[i] if self._counts[i] > 0 else [1./self._size for j in range(0,self._size)]
		return ret

	def predict(self, states, times=1):
		assert len(states) == self._size
		assert times > 0
		m = self.getMatrix()
		#print(m)
		ret = states.copy()
		for i in range(0,times):
			ret = ret @ m
		return ret

	def predictNext(self):
		if self._last_state != None:
			states = numpy.array([ (1 if i == self._last_state else 0) for i in range(0,self._size) ])
			return self.predict(states)
		return None

	def histogram(self):
		ret = numpy.array(self._counts, float)
		return ret / self._sample_size

	def increment(self, states):
		if isinstance(states, int):
			state_from = self._last_state
			state_to = states
		elif isinstance(states, tuple):
			state_from, state_to = states
		else: raise Exception('wrong parameter states')

		assert state_from == None or (state_from >=0 and state_from < self._size)
		assert state_to >= 0 and state_to < self._size

		if state_from != None:
			self._counts[state_from] += 1
			self._matrix[state_from][state_to] += 1
			self._sample_size += 1
			self._sample.append((state_from, state_to))

		self._last_state = state_to

		if self._sample_limit > 0:
			while self._sample_size > self._sample_limit:
				self.decrement()

	def decrement(self):
		if self._sample_size > 0:
			state_from, state_to = self._sample.pop(0)
			self._sample_size -= 1

			if self._counts[state_from] <= 0 or self._matrix[state_from][state_to] <= 0:
				self.debugData()
				raise Exception('self._counts[{f}] = {c} or self._matrix[{f}][{t}] = {m}'.format(f=state_from, t=state_to, c=self._counts[state_from], m=self._matrix[state_from][state_to]))

			self._counts[state_from] -= 1
			self._matrix[state_from][state_to] -= 1

	def size(self):
		return self._size

	def debugData(self):
		print('Sample Size       : {}'.format(self._sample_size))
		print('Counts            : {}'.format(self._counts))
		print('Transition Matrix : \n{}'.format(self._matrix))

if __name__ == '__main__':
	exit(Program().main())
