#!/usr/bin/env python3

import argparse
import psutil
import subprocess
import shlex
import datetime
import time
import collections
import zlib
import os

sc_clk_tck = os.sysconf(os.sysconf_names['SC_CLK_TCK'])

class Load:
	# Command parameters and options
	parser  = None
	options = None

	pid = None
	first_line = True
	last_time = None
	process   = None

	def __init__(self):
		self.parser = argparse.ArgumentParser(
			description="Load the system.")
		self.parser.add_argument('-b', '--builtin',
			default=None, choices=['zlib'],
			help='builtin functions')
		self.parser.add_argument('-c', '--command', type=str,
			default=None,
			help='command (use %%f for to indicate the file)')
		self.parser.add_argument('-f', '--files', type=str,
			default=None, nargs='+',
			help='list of files to process using the command')
		self.parser.add_argument('-l', '--loops', type=int,
			default=1,
			help='number of loops')
		self.parser.add_argument('-i', '--infinite',
			default=False, action='store_true',
			help='infinite loops')

		self.pid = os.getpid()

	def main(self):
		self.options = self.parser.parse_args()
		print(self.options)

		if self.options.files == None:
			self.options.files = [None]

		self.last_time = time.time()
		self.process   = psutil.Process(self.pid)
		count = 0
		while True:
			for i in self.options.files:
				if self.options.builtin != None:
					self.printLine(self.executeBuiltin(i))
				elif self.options.command != None:
					self.printLine(self.executeCommand(i))

			if self.options.infinite: continue
			count += 1
			if count >= self.options.loops: break

		return 0

	def printLine(self, output):
		if self.first_line:
			print('#'+'; '.join(output.keys()))
			self.first_line = False
		print( '; '.join( [str(i) for i in output.values()] ) )

	def executeBuiltin(self, file):
		ret = collections.OrderedDict()
		if self.options.builtin == 'zlib':
			f = open(file, 'rb')
			zlib.compress(f.read())
			f.close()
		cur_time = time.time()
		cpu_times = self.process.cpu_times()
		delta_time = cur_time - self.last_time
		ret['time'] = datetime.datetime.now().strftime('%s')
		ret['elapsed_time']    = round(delta_time, 3)
		ret['total']           = 0
		ret['user']            = cpu_times.user
		ret['system']          = cpu_times.system
		ret['children_user']   = cpu_times.children_user
		ret['children_system'] = cpu_times.children_system
		ret['total']           = ret['user'] + ret['system'] + ret['children_user'] + ret['children_system']
		self.last_time = cur_time
		#self.last_stat = cur_stat
		return ret

	def executeCommand(self, file):
		ret = collections.OrderedDict()
		cmd = self.options.command.replace('%f', file) if file != None else self.options.command
		cmd_list = shlex.split(cmd)
		time_start = time.time()
		p = psutil.Popen(cmd_list, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
		while True:
			time.sleep(0.01)
			cpu_times = p.cpu_times()
			if p.poll() != None:
				break
		time_end = time.time()
		ret['time']            = datetime.datetime.now().strftime('%s')
		ret['elapsed_time']    = round(time_end - time_start, 3)
		ret['total']           = round(((cpu_times.user + cpu_times.system)/(time_end - time_start))*100, 2)
		ret['user']            = cpu_times.user
		ret['system']          = cpu_times.system
		ret['children_user']   = cpu_times.children_user
		ret['children_system'] = cpu_times.children_system
		return ret

	'''def getProcStat(self):
		#SEE: man 5 proc
		f = open('/proc/{}/stat'.format(self.pid), 'r')
		s = f.readline().replace('\n','').split(' ')
		f.close()
		return s'''

if __name__ == '__main__':
	exit(Load().main())
