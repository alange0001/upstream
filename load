#!/usr/bin/env python3

import argparse
import psutil
import subprocess
import shlex
import datetime
import time
import collections
import zlib
import os
import sys

from util import max_round

class Load:
	# Command parameters and options
	options    = None
	# Output control
	first_line = True
	# Process and stats information
	#pid        = None
	#process    = None
	#last_time  = None
	#last_stat  = None

	def __init__(self):
		parser = argparse.ArgumentParser(
			description="Load the system.")
		parser.add_argument('-b', '--builtin',
			default=None, choices=['zlib'],
			help='builtin functions')
		parser.add_argument('-c', '--command', type=str,
			default=None,
			help='command (use %%f for to indicate the file)')
		parser.add_argument('-f', '--files', type=str,
			default=None, nargs='+',
			help='list of files to process using the command')
		parser.add_argument('-l', '--loops', type=int,
			default=0,
			help='number of loops (0 for infinite)')
		parser.add_argument('-s', '--sleep', type=float,
			default=0.,
			help='sleep interval between tasks')

		self.options = parser.parse_args()
		if self.options.files == None:
			self.options.files = [None]
		#print(self.options)

	def main(self):
		try:
			assert self.options.sleep >= 0
			assert self.options.loops >= 0

			#self.pid       = os.getpid()
			#self.process   = psutil.Process(self.pid)
			#self.last_time = time.time()
			#self.last_stat = self.process.cpu_times()

			count = 0
			while True:
				for i in self.options.files:
					if self.options.builtin != None:
						self.printLine(self.executeBuiltin(i))
					elif self.options.command != None:
						self.printLine(self.executeCommand(i))

					if self.options.sleep > 0:
						time.sleep(self.options.sleep)

				if self.options.loops == 0: continue
				count += 1
				if count >= self.options.loops: break

		# Exit conditions
		except KeyboardInterrupt:
			return 0
		except Exception as e:
			sys.stderr.write('error: {}\n'.format(str(e)))
			return 1
		return 0

	def printLine(self, output):
		if self.first_line:
			print('#'+'; '.join(output.keys()))
			self.first_line = False
		print( '; '.join( [str(i) for i in output.values()] ) )

	def executeBuiltin(self, file):
		m = Metrics()

		if self.options.builtin == 'zlib':
			f = open(file, 'rb')
			zlib.compress(f.read())
			f.close()

		m.saveTimes()
		return m.getResults()

	def executeCommand(self, file):
		ret = collections.OrderedDict()
		cmd = self.options.command.replace('%f', file) if file != None else self.options.command
		cmd_list = shlex.split(cmd)
		p = psutil.Popen(cmd_list, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
		m = Metrics(p)
		while True:
			time.sleep(0.01)
			m.saveTimes()
			if p.poll() != None:
				break

		return m.getResults()

class Metrics:
	_process        = None
	_first_time     = None
	_first_cputimes = None
	_first_ptimes   = None
	_cur_time       = None
	_cur_cputimes   = None
	_cur_ptimes     = None

	def __init__(self, process=None):
		self._process        = process if process != None else psutil.Process(os.getpid())
		self._first_time     = time.time()
		self._first_cputimes = psutil.cpu_times()
		self._first_ptimes   = self._process.cpu_times()

	def saveTimes(self):
		self._cur_time     = time.time()
		self._cur_cputimes = psutil.cpu_times()
		self._cur_ptimes   = self._process.cpu_times()

	def getResults(self):
		ret = collections.OrderedDict()

		first_time = self._first_time
		first_cputimes = self._first_cputimes
		first_ptimes = self._first_ptimes

		cur_time = self._cur_time
		cur_cputimes = self._cur_cputimes
		cur_ptimes = self._cur_ptimes

		delta_time = cur_time - self._first_time

		ret['time'] = datetime.datetime.now().strftime('%s')
		ret['elapsed_time']    = round(delta_time, 3)
		ret['total']           = max_round(100* (
		                            cur_cputimes.user - first_cputimes.user
		                            +cur_cputimes.nice - first_cputimes.nice
		                            +cur_cputimes.system - first_cputimes.system
		                            +cur_cputimes.softirq - first_cputimes.softirq
		                            +cur_cputimes.guest - first_cputimes.guest
		                            +cur_cputimes.guest_nice - first_cputimes.guest_nice
		                            )/(cur_time - first_time), 100, 2)
		ret['steal']           = max_round(100* (cur_cputimes.steal - first_cputimes.steal)/(cur_time - first_time), 100, 2)
		ret['process']         = max_round(100* (
		                            cur_ptimes.user - first_ptimes.user
		                            +cur_ptimes.system - first_ptimes.system
		                            +cur_ptimes.children_user - first_ptimes.children_user
		                            +cur_ptimes.children_system - first_ptimes.children_system
		                            )/(cur_time - first_time), 100, 2)

		return ret

if __name__ == '__main__':
	exit(Load().main())
