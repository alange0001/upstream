#!/usr/bin/env python3

import argparse
import psutil
import subprocess
import shlex
import datetime
import time
import collections
import zlib
import os

from util import max_round

class Load:
	# Command parameters and options
	parser  = None
	options = None
	# Output control
	first_line = True
	# Process and stats information
	pid       = None
	process   = None
	last_time = None
	last_stat = None

	def __init__(self):
		self.parser = argparse.ArgumentParser(
			description="Load the system.")
		self.parser.add_argument('-b', '--builtin',
			default=None, choices=['zlib'],
			help='builtin functions')
		self.parser.add_argument('-c', '--command', type=str,
			default=None,
			help='command (use %%f for to indicate the file)')
		self.parser.add_argument('-f', '--files', type=str,
			default=None, nargs='+',
			help='list of files to process using the command')
		self.parser.add_argument('-l', '--loops', type=int,
			default=1,
			help='number of loops')
		self.parser.add_argument('-i', '--infinite',
			default=False, action='store_true',
			help='infinite loops')

		self.pid     = os.getpid()
		self.process = psutil.Process(self.pid)

	def main(self):
		self.options = self.parser.parse_args()
		print(self.options)

		if self.options.files == None:
			self.options.files = [None]

		self.last_time = time.time()
		self.last_stat = self.process.cpu_times()

		count = 0
		while True:
			for i in self.options.files:
				if self.options.builtin != None:
					self.printLine(self.executeBuiltin(i))
				elif self.options.command != None:
					self.printLine(self.executeCommand(i))

			if self.options.infinite: continue
			count += 1
			if count >= self.options.loops: break

		return 0

	def printLine(self, output):
		if self.first_line:
			print('#'+'; '.join(output.keys()))
			self.first_line = False
		print( '; '.join( [str(i) for i in output.values()] ) )

	def executeBuiltin(self, file):
		ret = collections.OrderedDict()
		if self.options.builtin == 'zlib':
			f = open(file, 'rb')
			zlib.compress(f.read())
			f.close()

		cur_time = time.time()
		cpu_total = self.process.cpu_percent()
		cpu_times = self.process.cpu_times()
		delta_time = cur_time - self.last_time

		ret['time'] = datetime.datetime.now().strftime('%s')
		ret['elapsed_time']    = round(delta_time, 3)
		ret['total']           = max_round(cpu_total, 100, 2)
		ret['user']            = max_round(100* (cpu_times.user - self.last_stat.user)/(cur_time - self.last_time), 100, 2)
		ret['system']          = max_round(100* (cpu_times.system - self.last_stat.system)/(cur_time - self.last_time), 100, 2)
		ret['children_user']   = max_round(100* (cpu_times.children_user - self.last_stat.children_user)/(cur_time - self.last_time), 100, 2)
		ret['children_system'] = max_round(100* (cpu_times.children_system - self.last_stat.children_system)/(cur_time - self.last_time), 100, 2)

		self.last_time = cur_time
		self.last_stat = cpu_times
		return ret

	def executeCommand(self, file):
		ret = collections.OrderedDict()
		cmd = self.options.command.replace('%f', file) if file != None else self.options.command
		cmd_list = shlex.split(cmd)
		p = psutil.Popen(cmd_list, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
		time_start = time.time()
		while True:
			time.sleep(0.01)
			cpu_times = p.cpu_times()
			time_end = time.time()
			if p.poll() != None:
				break
		ret['time']            = datetime.datetime.now().strftime('%s')
		ret['elapsed_time']    = round(time_end - time_start, 3)
		ret['total']           = 0
		ret['user']            = max_round(100* cpu_times.user / (time_end - time_start), 100, 2)
		ret['system']          = max_round(100* cpu_times.system / (time_end - time_start), 100, 2)
		ret['children_user']   = max_round(100* cpu_times.children_user / (time_end - time_start), 100, 2)
		ret['children_system'] = max_round(100* cpu_times.children_system / (time_end - time_start), 100, 2)
		ret['total']           = max_round(ret['user'] + ret['system'] + ret['children_user'] + ret['children_system'], 100, 2)
		return ret

if __name__ == '__main__':
	exit(Load().main())
